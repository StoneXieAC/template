/*
poj1265 
在直角坐标系中，一个机器人从任意点出发进行 n 次移动，
每次向右移动 dx 向上移动 dy最后会形成一个平面上的封闭简单多边形
求边上的点的数量，多边形内的点的数量，多边形面积。

Pick 定理：给定顶点均为整点的简单多边形，皮克定理说明了其面积 A 和内部格点数目 i、边上格点数目 b 的关系：
A=i+b/2-1(没有取整,可能是小数)
取格点的组成图形的面积为一单位。在平行四边形格点，皮克定理依然成立。
套用于任意三角形格点，皮克定理则是 A=2*i+b-2
*/
const int N = 110;
Point p[N];

int gcd(int x, int y) { return y ? gcd(y, x % y) : x; }

void solve() {
    int n, dx, dy, num = 0, sum = 0;
    cin >> n;
    p[0].x = p[0].y = 0;
    for (int i = 1; i <= n; i++) {
        cin >> dx >> dy;
        p[i].x = p[i - 1].x + dx;
        p[i].y = p[i - 1].y + dy;
        num += gcd(abs(dx), abs(dy));//num为边上的点的数量
        sum += (p[i - 1] %[i]);//sum为两倍的面积
        //任意一个多边形的面积等于按顺序求相邻两个点与原点组成的向量的叉积之和的一半
    }
    sum = abs(sum);
    cout << (sum - num) / 2 + 1 << " " << num << " " << sum / 2.0 << "\n\n";
    //多边形内的点的数量，分别为边上的点的数量，多边形面积。
}
